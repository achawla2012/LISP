;; Author: Amardeep singh
;; Course: CS5211 Artificial Intelligence

(defstruct nodes state precussor depth)  ;; Node structure having details about its state, 
  									 ;; depth in a problem from initial state and its
										 ;;  precussor (parent node)
(defvar *openlist*)                      ;; list of nodes which has been visited
(defvar *action*)                        ;; Total operators
(defvar *checklist*)                     ;; list of nodes which has been visited and expanded
(defvar *missionaries*)					 ;; Number of missionaries
(defvar *cannibals*)					 ;; Number of cannibals
(defvar *close*)
(defvar *open*)
(defvar *opencheck*)                     ;; Holds state which are to generated by filtering out
										 ;; nodes which are in openlist.
(defvar *closecheck*)					 ;; Holds state which are to generated by filtering out
										 ;; nodes which are in closelist.

(defun is-goal-state(node)	             ;; returns true if state of node is a goal state     
	(if (equalp node *goal*) nil 't))

(defun operator ()                       ;; calculate possible operators
	(setq *action* nil)
	(loop for i from 6 downto 0 do 
		(loop for j from 0 to (- 6 i)  do 
			(if (and (= i 0) (> j 0)) (setq *action* (cons (list i j) *action*)))
			(if (and (>= i j ) ( not ( and (= i j) (= j 0)))) 
				(setq *action* (cons (list i j) *action*))))) *action*)


(defun nextnodes (state)                 ;; calculates possible child states using possible 
										 ;; operators on *current* state
	(setq *checklist* nil)
        (loop for action in *action* do
        	(setf temp nil)
		(if ( = (third state) '1)        ;; If boat is right side and want to move left then 
										 ;; add missionaries and cannibals at left and 
										 ;; substract the same from right else vice-versa.
			(progn  
				(setf temp ( cons (+ (first state) (first action)) temp))    
				(setf temp ( cons (+ (second state) (second action)) temp))
				(setf temp ( cons '0 temp))     ;; Boat moved to left
				(setf temp ( cons (- (fourth state) (first action)) temp))
				(setf temp ( cons (- (fifth state) (second action)) temp))
				(setf temp2 (reverse temp))
				(setf *checklist* (cons  temp2 *checklist*))) 
		                
			(progn  (setf temp ( cons (- (first state) (first action)) temp))
				(setf temp ( cons (- (second state) (second action)) temp))
		                (setf temp ( cons '1 temp))     ;; Boat moved to right
				(setf temp ( cons (+ (fourth state) (first action)) temp))
				(setf temp ( cons (+ (fifth state) (second action)) temp))
				(setf temp2 (reverse temp))
		                (setf *checklist* (cons temp2 *checklist*))))))

(defun safe-state ( state )         ;; calculates valid child states by filtering out states 
								    ;; with M < C & -ive count of cannibals and missionaries.
	(setf valid-state nil)  
	(dolist (x state)
		(if (and  (>= (first x) 0) (>= (second x) 0) (>= (fifth x) 0) (>= (fourth x) 0)
    		(<= (first x) *missionaries*) (<= (second x) *cannibals*) (<= (fourth x) *missionaries*)
 			(<= (fifth x) *cannibals*) (<= (+ (fourth x) (first x)) *missionaries*) (<= (+ (second x)
			(fifth x)) *cannibals*))
			(progn
				(if (and (>= (first x) (second x)) (<= (fifth x) (fourth x)))
						(setq valid-state (cons x valid-state))
					        (progn       	
							(if (or (= (first x) 0) (= (fourth x) 0))
					            (setq valid-state (cons x valid-state)))))))) (setq *checklist* valid-state))

(defvar *closecheck*)
(defun checkcloselist (checklist)        ;; checks if a state is already in closelist or not
	(if (not (null checklist))
		(progn
			(setq x (car checklist))
			(if (null (is-equal x *closelist*)) 
				(progn
					(if (null *closecheck*) 
						(setq *closecheck* (cons x *closecheck*))
						(setq *closecheck* (append *closecheck* (list x))))
					(checkcloselist (cdr checklist)))
				(progn (checkcloselist (cdr checklist)))))))

(defun is-equal(node list)	  		     ;; returns true if node is in list (open or close)
	(if (null list) (return-from is-equal nil))
	(dolist (x list)
		(if (not (null (equalp node (nodes-state x))))
			(progn 	
				(return-from is-equal 't)))) 
	(return-from is-equal nil))
		
(defun checkopenlist (checklist)        ;; checks if a state is already in openlist or not
	(if (not (null checklist))
		(progn
			(setq x (car checklist))
			(if (null (is-equal (car checklist) *openlist*)) 
				(progn
					(if (null *opencheck*) 
						(setq *opencheck* (cons x *opencheck*))
						(setq *opencheck* (append *opencheck* (list x))))
					(checkopenlist (cdr checklist)))
				(checkopenlist (cdr checklist))))))

(defun generate-node(check current)     ;; generates safe nodes not found in close and open list
	(if (not (null check))
		(progn
			(setq newnode (make-nodes :state (car check)
				   		 :precussor current
				   		 :depth (+ 1 (nodes-depth current))))
			(if (null *openlist*) 
					(setq *openlist* (cons newnode *openlist*))
					(setq *openlist* (append *openlist* (list newnode))))
		        (generate-node (cdr check) current))))

(defun is-goal-state(node)	  	 ;; returns true if state of node is a goal state
	(if (null (equalp node *goal*)) nil 't))

(defun is-openlist-empty()              ;; if openlist is empty then return true
	(if (null (car *openlist*)) 't nil))
	        
(defun cannibals(istate)                ;; Main function to start from here. 
	(setq start (make-nodes :state istate
                         	:precussor nil
                         	:depth 0))
;;istate < N N 0 0 0> : N missionaries & cannibals on left with boat on left							
    (setq temp (first istate))     
;; setting value of missionaries with first element of "istate" list, i.e N
	(setq *missionaries* temp)     
;; setting value of missionaries with first element of "istate" list, i.e N
	(setq *cannibals* temp)		   
    (setq *goal* nil)
	(setq *closecheck* nil)         
	(setq *opencheck* nil)
	(setq *close* nil)
    (setq *open* nil)
    (setq *openlist* nil)
    (setq *closelist* nil)
 ;; calculating goal state such that N missionaries and cannibals on right side	
	(setq *goal* (cons (first istate) (cons (second istate) *goal*)))
 ;; Boat on right hand side. *goal* <0 0 1 N N>
	(setq *goal* (cons '0 (cons '0 (cons '1 *goal*))))  
	(format t "~%~%Goal State (Missionaries-left,Cannibals-left, Boat (left 0|right 1),
    Missionaries-right,Cannibals-right  -> ~A ~%" *goal*)
	(operator)                 ;; Calculate possible actions (M,C) such that M>=C 
	(format t "Action(M,C) where M>=C ~A ~%~%" *action*)
    (setq mov 0)
	(setq *openlist* (cons start *openlist*))
	(loop while (null (is-openlist-empty)) do	;; if openlist is empty then return true
		(setq *current* (car *openlist*))
		(if (is-goal-state (nodes-state *current*)) ;; if current state is a goal 
    			(progn 
                    	(format t "Total ~A Moves from initial to goal state" (nodes-depth *current*))
				(format t "~%Total nodes expanded ~A ~%" (length *closelist*))
				(setf *result* nil)
				(printpath *current*) (setq *result* (cons istate *result*)) (setq *result* (cdr *result*))
				(setf initial istate)
				(dolist (x *result*)
				;; If boat is on right, move is right else left.
				;; Substracting previous state with current gives number of missionaries 
				;; cannibals move from last state
					(if (= (third x) '1)            
						(progn                      
							(format t "Move right -> Missionaries: ~A Cannibals: ~A " 
							(abs (- (first Initial) (first x))) (abs (- (second Initial) (second x)))))
						(progn 
							(format t "Move left -> Missionaries: ~A Cannibals: ~A " 
							(abs (- (first Initial) (first x))) (abs (- (second Initial) (second x)))))) 
							(setq initial x) (format t "   Current state: ~A ~%" x) )
				(return-from cannibals 'END)))
		(setq *closecheck* nil)
		(setq *opencheck* nil)
		(setq *openlist* (cdr *openlist*) )         
		(setq *closelist* (cons *current* *closelist*)) ;; move current state from open to close list.
		(nextnodes (nodes-state *current*))         ;;  Generate possible states from *current* 
													;;  state and save it in *checklist* 
		(safe-state *checklist*)					;;  removes state with M,C <0 and C>M
		(setq *checklist* (checkcloselist *checklist*))  ;; Check if states in *checklist* present in 
														 ;; *closelist*
		(setq *checklist* *closecheck*)				
		(checkopenlist *checklist*)	        ;; Check if states in *checklist* present in *openlist*
		(setq *checklist* *opencheck*) (setq mov (+ mov 1))
		(generate-node *checklist* *current*)))	;; Generate nodes for states present in
												;; *checklist*
 
(defvar *result*)
(defun printpath (path)						;; Find path from Initial state to Final state.	
;; add states in the path until parent value is not NIL. 
;; If this happens it means we have reached initial state from final state	
	(if (not (null (nodes-precussor path)))
		(progn
			(setq value (nodes-state path))			
			;;(print value)
			(setq *result* (cons value *result*))    
			(setq path (nodes-precussor path))
		        (printpath path))
                (setq *result (cons (nodes-state path) *result*))))		
